{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"crosszip","text":"<p><code>crosszip</code> is a Python utility that makes it easy to apply a function to all possible combinations of elements from multiple iterables. It combines the power of the Cartesian product and functional programming into a single, intuitive tool.</p> <p>Additionally, <code>@pytest.mark.crosszip_parametrize</code> is a <code>pytest</code> marker that simplifies running tests with all possible combinations of parameter values.</p>"},{"location":"#installation","title":"Installation","text":"Package Manager Installation Command pip <code>pip install crosszip</code> uv <code>uv add crosszip</code>"},{"location":"#usage","title":"Usage","text":"<p>Example of using <code>crosszip</code>:</p> <pre><code># Label Generation for Machine Learning\n\nfrom crosszip import crosszip\n\n\ndef create_label(category, subcategory, version):\n    return f\"{category}_{subcategory}_v{version}\"\n\n\ncategories = [\"cat\", \"dog\"]\nsubcategories = [\"small\", \"large\"]\nversions = [\"1.0\", \"2.0\"]\n\nlabels = crosszip(create_label, categories, subcategories, versions)\nprint(labels)\n</code></pre> <pre><code>['cat_small_v1.0', 'cat_small_v2.0', 'cat_large_v1.0', 'cat_large_v2.0', 'dog_small_v1.0', 'dog_small_v2.0', 'dog_large_v1.0', 'dog_large_v2.0']\n</code></pre> <p>Example of using <code>pytest</code> marker <code>crosszip_parametrize</code>:</p> <pre><code># Testing Power Function\n\nimport math\nimport crosszip\nimport pytest\n\n\n@pytest.mark.crosszip_parametrize(\n    \"base\",\n    [2, 10],\n    \"exponent\",\n    [-1, 0, 1],\n)\ndef test_power_function(base, exponent):\n    result = math.pow(base, exponent)\n    assert result == base**exponent\n\nprint(\"Tests executed successfully.\")\n</code></pre> <pre><code>Tests executed successfully.\n</code></pre> <p>For more examples, check out the package documentation at: https://indrajeetpatil.github.io/crosszip/</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Flexible Input: Works with any iterables, including lists, tuples,   sets, and generators.</li> <li>pytest Plugin: Provides a <code>crosszip_parametrize</code> marker for   running tests with all possible combinations of parameter values.</li> <li>Simple API: Minimalist, intuitive design for quick integration   into your projects.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Hex sticker font is <code>Rubik</code>, and the image is taken from icon made by Freepik and available at flaticon.com.</p> <p>Executable code snippets use JavaScript code from Samuel Colvin of Pydantic.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#130","title":"1.3.0","text":"<ul> <li>Adds support for Python version <code>3.14</code>.</li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":"<ul> <li>No user-facing changes.</li> </ul>"},{"location":"changelog/#110","title":"1.1.0","text":"<ul> <li>Extends support to Python versions <code>3.10</code> and <code>3.11</code>.</li> </ul>"},{"location":"changelog/#100","title":"1.0.0","text":"<ul> <li>Adds pytester tests for the <code>pytest</code>-plugin.</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<ul> <li>Fixes <code>crosszip_parametrize</code> marker for <code>pytest</code> plugin. There was a bug in the implementation that caused the marker to not be recognized by <code>pytest</code>.</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<ul> <li>Initial release of <code>crosszip</code> package.</li> </ul>"},{"location":"integrations/llms/","title":"LLM Integration","text":"<p>The crosszip documentation is available in the llms.txt format. This format is defined in Markdown and suited for large language models.</p> <p>Two formats are available:</p> <ul> <li>llms.txt: a file   containing a brief description of the project, along with links to the   different sections of the documentation. The structure of this file is   described in details in the   format documentation.</li> <li>llms-full.txt:   Similar to the <code>llms.txt</code> file, but every link content is included. Note   that this file may be too large for some LLMs.</li> </ul> <p>As of today, these files cannot be natively leveraged by LLM frameworks or IDEs. Alternatively, a MCP server can be implemented to properly parse the <code>llms.txt</code> file.</p>"},{"location":"reference/crosszip/","title":"crosszip","text":""},{"location":"reference/crosszip/#crosszip.crosszip.crosszip","title":"<code>crosszip(func, *iterables)</code>","text":"<p>Apply a given function to all combinations of elements from multiple iterables.</p> <p>This function computes the Cartesian product of the input iterables (i.e., all possible combinations of their elements) and applies the provided function to each combination.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., T]</code> <p>A function that accepts as many arguments as there are iterables.</p> required <code>*iterables</code> <code>Iterable[T]</code> <p>Two or more iterables to generate combinations from. Each iterable should contain elements that are valid inputs for the function <code>func</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>list[T]</code> <p>list[T]: A list of results from applying the function to each combination of elements.</p> Example <pre><code># Example 1: Basic usage with lists\ndef concat(a, b, c):\n    return f\"{a}-{b}-{c}\"\n\n\nlist1 = [1, 2]\nlist2 = [\"a\", \"b\"]\nlist3 = [True, False]\n\ncrosszip(concat, list1, list2, list3)\n# ['1-a-True', '1-a-False', '1-b-True', '1-b-False', '2-a-True', '2-a-False',\n#  '2-b-True', '2-b-False']\n\n\n# Example 2: Using tuples and a mathematical function\ndef add(a, b):\n    return a + b\n\n\ncrosszip(add, (1, 2), (10, 20))\n[11, 21, 12, 22]\n\n# Example 3: Using sets (order may vary) and a string concatenation function\ncrosszip(concat, {1, 2}, {\"x\", \"y\"}, {\"foo\", \"bar\"})\n# ['1-x-foo', '1-x-bar', '1-y-foo', '1-y-bar', '2-x-foo', '2-x-bar',\n#  '2-y-foo', '2-y-bar']\n\n\n# Example 4: Using a generator\ndef gen():\n    yield 1\n    yield 2\n\n\ncrosszip(concat, gen(), [\"a\", \"b\"], [\"x\", \"y\"])\n# &gt;&gt; ['1-a-x', '1-a-y', '1-b-x', '1-b-y', '2-a-x', '2-a-y', '2-b-x', '2-b-y']\n</code></pre> Notes <ul> <li> <p>The function assumes that each iterable contains values   compatible with the function <code>func</code>.</p> </li> <li> <p>For large input iterables, the number of combinations grows exponentially,   so use with care when working with large datasets.</p> </li> </ul> Source code in <code>src/crosszip/crosszip.py</code> <pre><code>def crosszip(func: Callable[..., T], *iterables: Iterable[Any]) -&gt; list[T]:\n    \"\"\"\n    Apply a given function to all combinations of elements from multiple iterables.\n\n    This function computes the Cartesian product of the input iterables (i.e., all\n    possible combinations of their elements) and applies the provided function to each\n    combination.\n\n    Args:\n        func (Callable[..., T]): A function that accepts as many arguments as there are\n            iterables.\n        *iterables (Iterable[T]): Two or more iterables to generate combinations from.\n            Each iterable should contain elements that are valid inputs for the function\n            `func`.\n\n    Returns:\n        list[T]: A list of results from applying the function to each combination of\n            elements.\n\n    Example:\n        ```python\n        # Example 1: Basic usage with lists\n        def concat(a, b, c):\n            return f\"{a}-{b}-{c}\"\n\n\n        list1 = [1, 2]\n        list2 = [\"a\", \"b\"]\n        list3 = [True, False]\n\n        crosszip(concat, list1, list2, list3)\n        # ['1-a-True', '1-a-False', '1-b-True', '1-b-False', '2-a-True', '2-a-False',\n        #  '2-b-True', '2-b-False']\n\n\n        # Example 2: Using tuples and a mathematical function\n        def add(a, b):\n            return a + b\n\n\n        crosszip(add, (1, 2), (10, 20))\n        [11, 21, 12, 22]\n\n        # Example 3: Using sets (order may vary) and a string concatenation function\n        crosszip(concat, {1, 2}, {\"x\", \"y\"}, {\"foo\", \"bar\"})\n        # ['1-x-foo', '1-x-bar', '1-y-foo', '1-y-bar', '2-x-foo', '2-x-bar',\n        #  '2-y-foo', '2-y-bar']\n\n\n        # Example 4: Using a generator\n        def gen():\n            yield 1\n            yield 2\n\n\n        crosszip(concat, gen(), [\"a\", \"b\"], [\"x\", \"y\"])\n        # &gt;&gt; ['1-a-x', '1-a-y', '1-b-x', '1-b-y', '2-a-x', '2-a-y', '2-b-x', '2-b-y']\n        ```\n\n    Notes:\n        - The function assumes that each iterable contains values\n          compatible with the function `func`.\n\n        - For large input iterables, the number of combinations grows exponentially,\n          so use with care when working with large datasets.\n\n    \"\"\"\n    combinations = itertools.product(*iterables)\n    return list(itertools.starmap(func, combinations))\n</code></pre>"},{"location":"reference/plugin/","title":"pytest-plugin: crosszip_parametrize","text":""},{"location":"reference/plugin/#crosszip.plugin.pytest_configure","title":"<code>pytest_configure(config)</code>","text":"<p>Register the <code>crosszip_parametrize</code> marker with pytest.</p> <p>This pytest hook registers the <code>crosszip_parametrize</code> marker with pytest. The marker is used to parametrize tests with the Cartesian product of parameter values.</p> Source code in <code>src/crosszip/plugin.py</code> <pre><code>@pytest.hookimpl(trylast=True)\ndef pytest_configure(config: pytest.Config) -&gt; None:\n    \"\"\"\n    Register the `crosszip_parametrize` marker with pytest.\n\n    This pytest hook registers the `crosszip_parametrize` marker with pytest. The marker\n    is used to parametrize tests with the Cartesian product of parameter values.\n    \"\"\"\n    config.addinivalue_line(\n        \"markers\",\n        \"crosszip_parametrize(*args): mark test to be cross-parametrized\",\n    )\n</code></pre>"},{"location":"reference/plugin/#crosszip.plugin.pytest_generate_tests","title":"<code>pytest_generate_tests(metafunc)</code>","text":"<p>Generate parametrized tests using the cross-product of parameter values.</p> <p>This pytest hook parametrizes tests based on the <code>crosszip_parametrize</code> marker. It extracts parameter names and their corresponding lists of values, computes their Cartesian product, and parametrizes the test function accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>metafunc</code> <code>Metafunc</code> <p>The test function's metadata provided by pytest.</p> required Example <pre><code>import math\nimport crosszip\nimport pytest\n\n\n@pytest.mark.crosszip_parametrize(\n    \"base\",\n    [2, 10],\n    \"exponent\",\n    [-1, 0, 1],\n)\ndef test_power_function(base, exponent):\n    result = math.pow(base, exponent)\n    assert result == base**exponent\n\n\n@pytest.mark.crosszip_parametrize()\ndef test_example():\n    pass\n\n\n# Error: Parameter names and values must be provided.\n\n\n@pytest.mark.crosszip_parametrize(\n    \"x\",\n    1,\n    \"y\",\n    [3, 4],\n)\ndef test_example(x, y):\n    pass\n\n\n# Error: All parameter values must be non-empty sequences.\n</code></pre> Source code in <code>src/crosszip/plugin.py</code> <pre><code>def pytest_generate_tests(metafunc: pytest.Metafunc) -&gt; None:\n    \"\"\"\n    Generate parametrized tests using the cross-product of parameter values.\n\n    This pytest hook parametrizes tests based on the `crosszip_parametrize` marker.\n    It extracts parameter names and their corresponding lists of values, computes their\n    Cartesian product, and parametrizes the test function accordingly.\n\n    Args:\n        metafunc (pytest.Metafunc): The test function's metadata provided by pytest.\n\n    Example:\n        ```python\n        import math\n        import crosszip\n        import pytest\n\n\n        @pytest.mark.crosszip_parametrize(\n            \"base\",\n            [2, 10],\n            \"exponent\",\n            [-1, 0, 1],\n        )\n        def test_power_function(base, exponent):\n            result = math.pow(base, exponent)\n            assert result == base**exponent\n\n\n        @pytest.mark.crosszip_parametrize()\n        def test_example():\n            pass\n\n\n        # Error: Parameter names and values must be provided.\n\n\n        @pytest.mark.crosszip_parametrize(\n            \"x\",\n            1,\n            \"y\",\n            [3, 4],\n        )\n        def test_example(x, y):\n            pass\n\n\n        # Error: All parameter values must be non-empty sequences.\n        ```\n\n    \"\"\"\n    marker = metafunc.definition.get_closest_marker(\"crosszip_parametrize\")\n    if marker:\n        args: tuple[Any, ...] = marker.args\n        param_names: tuple[Any, ...] = args[::2]\n        param_values: tuple[Any, ...] = args[1::2]\n\n        validate_parameters(param_names, param_values)\n\n        combinations: list[tuple[Any, ...]] = list(product(*param_values))\n        param_names_str: str = \",\".join(param_names)\n        metafunc.parametrize(param_names_str, combinations)\n</code></pre>"}]}